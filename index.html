<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HHJJ 3D ë„ì–´ë½ ì‹œë®¬ë ˆì´í„°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', sans-serif;
            background: #1a1a2e;
            overflow: hidden;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #ui-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 100;
            pointer-events: none;
        }
        
        .panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }
        
        h1 {
            color: #667eea;
            font-size: 1.8em;
            margin-bottom: 10px;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        .scenario-btn {
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
            font-size: 0.85em;
        }
        
        .scenario-btn.normal { background: linear-gradient(135deg, #84fab0, #8fd3f4); }
        .scenario-btn.loitering { background: linear-gradient(135deg, #fbc2eb, #a6c1ee); }
        .scenario-btn.intrusion { background: linear-gradient(135deg, #fa709a, #fee140); }
        .scenario-btn.critical { background: linear-gradient(135deg, #ff0844, #ffb199); }
        .scenario-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
        
        .status-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            pointer-events: auto;
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }
        
        .status-item {
            background: rgba(255, 255, 255, 0.95);
            padding: 12px;
            border-radius: 10px;
            text-align: center;
        }
        
        .status-label {
            font-size: 0.75em;
            color: #666;
            margin-bottom: 5px;
        }
        
        .status-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
        }
        
        .risk-indicator {
            position: fixed;
            top: 50%;
            right: 30px;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            pointer-events: auto;
            min-width: 150px;
        }
        
        .risk-level {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .risk-level.LOW { color: #84fab0; }
        .risk-level.MEDIUM { color: #fbc2eb; }
        .risk-level.HIGH { color: #fa709a; }
        .risk-level.CRITICAL { color: #ff0844; animation: pulse 1s infinite; }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .instructions {
            font-size: 0.85em;
            color: #999;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="ui-overlay">
        <div class="panel">
            <h1>ğŸ”’ HHJJ 3D ë„ì–´ë½ ì‹œë®¬ë ˆì´í„°</h1>
            <p style="color: #666; font-size: 0.9em;">ì‹¤ì‹œê°„ 3D ìœ„í—˜ ê°ì§€ ì‹œë®¬ë ˆì´ì…˜</p>
            
            <div class="controls">
                <button class="scenario-btn normal" onclick="startScenario('normal')">
                    âœ… ì •ìƒ ë°©ë¬¸
                </button>
                <button class="scenario-btn loitering" onclick="startScenario('loitering')">
                    âš ï¸ ì˜ì‹¬ ë°°íšŒ
                </button>
                <button class="scenario-btn intrusion" onclick="startScenario('intrusion')">
                    ğŸš¨ ì¹¨ì… ì‹œë„
                </button>
                <button class="scenario-btn critical" onclick="startScenario('critical')">
                    ğŸ†˜ ê°•ì œ íŒŒì†
                </button>
            </div>
            
            <div class="instructions">
                ğŸ–±ï¸ ë§ˆìš°ìŠ¤ë¡œ ì‹œì  íšŒì „ | ğŸ” ìŠ¤í¬ë¡¤ë¡œ ì¤Œ ì¸/ì•„ì›ƒ
            </div>
        </div>
    </div>
    
    <div class="risk-indicator">
        <div class="risk-level" id="risk-level">LOW</div>
        <div style="font-size: 0.9em; color: #666;">ìœ„í—˜ë„</div>
        <div style="margin-top: 10px; font-size: 0.85em;" id="elapsed-time">0ì´ˆ</div>
    </div>
    
    <div class="status-panel">
        <div class="panel">
            <div class="status-grid">
                <div class="status-item">
                    <div class="status-label">ê±°ë¦¬</div>
                    <div class="status-value" id="distance-value">300cm</div>
                </div>
                <div class="status-item">
                    <div class="status-label">ì²´ë¥˜ì‹œê°„</div>
                    <div class="status-value" id="dwell-value">0ì´ˆ</div>
                </div>
                <div class="status-item">
                    <div class="status-label">ì§„ë™</div>
                    <div class="status-value" id="vibration-value">0.0g</div>
                </div>
                <div class="status-item">
                    <div class="status-label">ìŒì••</div>
                    <div class="status-value" id="audio-value">40dB</div>
                </div>
                <div class="status-item">
                    <div class="status-label">ì „ì›</div>
                    <div class="status-value" id="power-value">âœ…</div>
                </div>
                <div class="status-item">
                    <div class="status-label">ì™¸í•¨</div>
                    <div class="status-value" id="tamper-value">ğŸ”’</div>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Three.js ê¸°ë³¸ ì„¤ì •
        let scene, camera, renderer, door, person, sensors, doorLock;
        let sensorData = { distance: 300, dwellTime: 0, vibration: 0, audio: 40, powerNormal: true, housingOpen: false };
        let currentScenario = null, elapsedTime = 0, simulationInterval = null;
        
        // ì”¬ ì´ˆê¸°í™”
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 10, 50);
            
            // ì¹´ë©”ë¼
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 8);
            camera.lookAt(0, 2, 0);
            
            // ë Œë”ëŸ¬
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // ì¡°ëª…
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // ë°”ë‹¥
            const floorGeometry = new THREE.PlaneGeometry(20, 20);
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // ë²½ (í˜„ê´€)
            const wallGeometry = new THREE.BoxGeometry(10, 5, 0.2);
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xf5f5dc });
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.set(0, 2.5, -3);
            wall.receiveShadow = true;
            scene.add(wall);
            
            // ë¬¸
            const doorGeometry = new THREE.BoxGeometry(1.5, 3, 0.1);
            const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 1.5, -2.9);
            door.castShadow = true;
            scene.add(door);
            
            // ë„ì–´ë½ (ë¬¸ ì˜†)
            const lockGeometry = new THREE.BoxGeometry(0.3, 0.4, 0.15);
            const lockMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            doorLock = new THREE.Mesh(lockGeometry, lockMaterial);
            doorLock.position.set(0.6, 1.5, -2.85);
            scene.add(doorLock);
            
            // ToF ì„¼ì„œ í‘œì‹œ (3ê°œ)
            sensors = new THREE.Group();
            for (let i = 0; i < 3; i++) {
                const sensorGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.1);
                const sensorMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00ff00,
                    emissive: 0x00ff00,
                    emissiveIntensity: 0.5
                });
                const sensor = new THREE.Mesh(sensorGeometry, sensorMaterial);
                sensor.position.set((i - 1) * 0.3, 0.5, -2.8);
                sensor.rotation.x = Math.PI / 2;
                sensors.add(sensor);
            }
            scene.add(sensors);
            
            // ì¸ë¬¼ (ê°„ë‹¨í•œ ë°•ìŠ¤ ìºë¦­í„°)
            const personGeometry = new THREE.BoxGeometry(0.6, 1.8, 0.4);
            const personMaterial = new THREE.MeshStandardMaterial({ color: 0x4169e1 });
            person = new THREE.Mesh(personGeometry, personMaterial);
            person.position.set(0, 0.9, 3);
            person.castShadow = true;
            scene.add(person);
            
            // ë§ˆìš°ìŠ¤ ì»¨íŠ¸ë¡¤
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            renderer.domElement.addEventListener('mousedown', () => isDragging = true);
            renderer.domElement.addEventListener('mouseup', () => isDragging = false);
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    camera.position.x += deltaX * 0.01;
                }
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                camera.position.z += e.deltaY * 0.01;
                camera.position.z = Math.max(3, Math.min(15, camera.position.z));
            });
            
            // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
            animate();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // ì„¼ì„œ ë°œê´‘ ì• ë‹ˆë©”ì´ì…˜
            sensors.children.forEach((sensor, i) => {
                sensor.material.emissiveIntensity = 0.3 + Math.sin(Date.now() * 0.002 + i) * 0.2;
            });
            
            // ìœ„í—˜ë„ì— ë”°ë¥¸ ë„ì–´ë½ ìƒ‰ìƒ ë³€í™”
            const risk = calculateRisk();
            if (risk.riskLevel === 'LOW') {
                doorLock.material.color.setHex(0x00ff00);
                doorLock.material.emissive = new THREE.Color(0x00ff00);
                doorLock.material.emissiveIntensity = 0.3;
            } else if (risk.riskLevel === 'MEDIUM') {
                doorLock.material.color.setHex(0xffff00);
                doorLock.material.emissive = new THREE.Color(0xffff00);
                doorLock.material.emissiveIntensity = 0.5;
            } else if (risk.riskLevel === 'HIGH') {
                doorLock.material.color.setHex(0xff8800);
                doorLock.material.emissive = new THREE.Color(0xff8800);
                doorLock.material.emissiveIntensity = 0.7;
            } else {
                doorLock.material.color.setHex(0xff0000);
                doorLock.material.emissive = new THREE.Color(0xff0000);
                doorLock.material.emissiveIntensity = 1.0;
                // CRITICAL ì‹œ ë„ì–´ë½ ì§„ë™ íš¨ê³¼
                doorLock.position.x = 0.6 + Math.sin(Date.now() * 0.02) * 0.05;
            }
            
            renderer.render(scene, camera);
        }
        
        // ìœ„í—˜ë„ ê³„ì‚°
        function calculateRisk() {
            let d = (300 - sensorData.distance) / 300;
            let t = Math.min(sensorData.dwellTime / 300, 1);
            let v = Math.min(sensorData.vibration / 10, 1);
            let a = Math.min(Math.max((sensorData.audio - 40) / 80, 0), 1);
            let p = sensorData.powerNormal ? 0 : 1;
            let h = sensorData.housingOpen ? 1 : 0;
            let score = d * 0.25 + t * 0.20 + v * 0.20 + a * 0.15 + p * 0.10 + h * 0.10;
            
            let level = score < 0.3 ? 'LOW' : score < 0.6 ? 'MEDIUM' : score < 0.85 ? 'HIGH' : 'CRITICAL';
            return { riskLevel: level, score: score };
        }
        
        // ì‹œë‚˜ë¦¬ì˜¤
        const scenarios = {
            normal: {
                duration: 40,
                update: (t) => {
                    // ì¸ë¬¼ì´ ì ‘ê·¼ â†’ ì •ì§€ â†’ í›„í‡´
                    if (t < 5) {
                        person.position.z = 3 - t * 0.5;
                        sensorData.distance = 200 - t * 30;
                    } else if (t < 30) {
                        person.position.z = 0.5;
                        sensorData.distance = 50;
                    } else {
                        person.position.z = 0.5 + (t - 30) * 0.25;
                        sensorData.distance = 50 + (t - 30) * 25;
                    }
                    sensorData.dwellTime = t;
                    sensorData.audio = t === 10 ? 70 : 40;
                }
            },
            loitering: {
                duration: 120,
                update: (t) => {
                    person.position.z = 0.5 + Math.sin(t * 0.1) * 0.2;
                    person.position.x = Math.sin(t * 0.05) * 0.3;
                    sensorData.distance = 50 + Math.random() * 10;
                    sensorData.dwellTime = t;
                }
            },
            intrusion: {
                duration: 180,
                update: (t) => {
                    person.position.z = 0.3;
                    sensorData.distance = 50;
                    sensorData.dwellTime = t;
                    
                    if (t > 90) {
                        sensorData.vibration = 3 + Math.random() * 2;
                        sensorData.audio = 85 + Math.random() * 10;
                        // ë¬¸ í”ë“¤ë¦¼ íš¨ê³¼
                        door.rotation.y = Math.sin(t * 0.3) * 0.05;
                        // ì¸ë¬¼ì´ ë¬¸ì„ ê³µê²©í•˜ëŠ” ë™ì‘
                        person.position.z = 0.1 + Math.sin(t * 0.5) * 0.1;
                    }
                }
            },
            critical: {
                duration: 200,
                update: (t) => {
                    person.position.z = 0.1;
                    sensorData.distance = 30;
                    sensorData.dwellTime = t;
                    
                    if (t > 120) {
                        sensorData.vibration = 5 + Math.random() * 3;
                        sensorData.audio = 90 + Math.random() * 10;
                        door.rotation.y = Math.sin(t * 0.5) * 0.1;
                    }
                    
                    if (t > 150) {
                        sensorData.housingOpen = true;
                        // ë„ì–´ë½ ì™¸í•¨ì´ ë²Œì–´ì§€ëŠ” íš¨ê³¼
                        doorLock.scale.x = 1.2;
                    }
                    
                    if (t > 180) {
                        sensorData.powerNormal = false;
                        // ì „ì› ì°¨ë‹¨ ì‹œ í™”ë©´ ì–´ë‘ì›Œì§
                        scene.background = new THREE.Color(0x330000);
                    }
                }
            }
        };
        
        function startScenario(name) {
            resetSimulation();
            currentScenario = name;
            
            simulationInterval = setInterval(() => {
                elapsedTime++;
                
                if (elapsedTime <= scenarios[currentScenario].duration) {
                    scenarios[currentScenario].update(elapsedTime);
                    updateUI();
                }
            }, 1000);
        }
        
        function updateUI() {
            document.getElementById('distance-value').textContent = Math.round(sensorData.distance) + 'cm';
            document.getElementById('dwell-value').textContent = sensorData.dwellTime + 'ì´ˆ';
            document.getElementById('vibration-value').textContent = sensorData.vibration.toFixed(1) + 'g';
            document.getElementById('audio-value').textContent = Math.round(sensorData.audio) + 'dB';
            document.getElementById('power-value').textContent = sensorData.powerNormal ? 'âœ…' : 'âŒ';
            document.getElementById('tamper-value').textContent = sensorData.housingOpen ? 'ğŸ”“' : 'ğŸ”’';
            document.getElementById('elapsed-time').textContent = elapsedTime + 'ì´ˆ';
            
            const risk = calculateRisk();
            const riskElem = document.getElementById('risk-level');
            riskElem.textContent = risk.riskLevel;
            riskElem.className = 'risk-level ' + risk.riskLevel;
        }
        
        function resetSimulation() {
            if (simulationInterval) clearInterval(simulationInterval);
            elapsedTime = 0;
            sensorData = { distance: 300, dwellTime: 0, vibration: 0, audio: 40, powerNormal: true, housingOpen: false };
            person.position.set(0, 0.9, 3);
            door.rotation.y = 0;
            doorLock.scale.set(1, 1, 1);
            doorLock.position.x = 0.6;
            scene.background = new THREE.Color(0x87ceeb);
            updateUI();
        }
        
        // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // ì´ˆê¸°í™”
        initScene();
        resetSimulation();
    </script>
</body>
</html>
